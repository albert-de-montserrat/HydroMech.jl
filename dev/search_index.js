var documenterSearchIndex = {"docs":
[{"location":"justrelax-Testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"justrelax-Testing/","page":"Testing","title":"Testing","text":"The implemented solvers of JustRelax.jl can be easily used given the following environment setup.","category":"page"},{"location":"justrelax-Testing/","page":"Testing","title":"Testing","text":"# Example script for running the 2D Stokes solvers\nusing JustRelax\nusing Printf, LinearAlgebra, CairoMakie\n\n# setup ParallelStencil.jl environment\nmodel = PS_Setup(:cpu, Float64, 2)\nenvironment!(model)\n\n# choose benchmark\nbenchmark = :solcx\n\n# model resolution (number of gridpoints)\nnx, ny = 128, 128\n\n# :single for a single run model with nx, ny resolution\n# :multiple for grid sensitivy error plot\nruntype = :single\n\nif benchmark == :solcx\n    # include plotting and error related functions\n    include(\"solcx/SolCx.jl\") # need to call this again if we switch from gpu <-> cpu\n    \n    # viscosity contrast\n    ∆η = 1e6\n    \n    if runtype == :single\n        # run model\n        geometry, stokes, iters, ρ = solCx(∆η; nx=nx, ny=ny)\n    \n        # plot model output and error\n        f = plot_solCx_error(geometry, stokes, ∆η; cmap=:romaO)\n    elseif runtype == :multiple\n        f = multiple_solCx(; ∆η=∆η, nrange=6:10) # nx = ny = 2^(nrange)-1\n    end\nelseif ...\n(...)\nend","category":"page"},{"location":"parallelstencil/#[ParallelStencil.jl](https://github.com/omlins/ParallelStencil.jl)-API","page":"ParallelStencil","title":"ParallelStencil.jl API","text":"","category":"section"},{"location":"parallelstencil/","page":"ParallelStencil","title":"ParallelStencil","text":"The following API is created using the docstrings avaliable within the ParallelStencil.jl package, and is included for convinience here for look-up purpose. Please refer to the official repository and ask the creator of the packages if anything is unclear.","category":"page"},{"location":"parallelstencil/","page":"ParallelStencil","title":"ParallelStencil","text":"CurrentModule = ParallelStencil","category":"page"},{"location":"parallelstencil/","page":"ParallelStencil","title":"ParallelStencil","text":"Modules = [ParallelStencil]","category":"page"},{"location":"parallelstencil/#ParallelStencil.ParallelStencil","page":"ParallelStencil","title":"ParallelStencil.ParallelStencil","text":"Module ParallelStencil\n\nEnables domain scientists to write high-level code for parallel high-performance stencil computations that can be deployed on both GPUs and CPUs.\n\nGeneral overview and examples\n\nhttps://github.com/omlins/ParallelStencil.jl\n\nPrimary macros\n\n@init_parallel_stencil\n@parallel\n@hide_communication\n@zeros\n@ones\n@rand\n\nnote: Advanced\n@parallel_indices\n@parallel_async\n@synchronize\n\nMacros available for @parallel_indices kernels\n\n@ps_show\n@ps_println\n\nnote: Advanced\n@gridDim\n@blockIdx\n@blockDim\n@threadIdx\n@sync_threads\n@sharedMem\n\nSubmodules\n\nParallelStencil.FiniteDifferences1D\nParallelStencil.FiniteDifferences2D\nParallelStencil.FiniteDifferences3D\n\nModules generated in caller\n\nData\n\nTo see a description of a macro or module type ?<macroname> (including the @) or ?<modulename>, respectively.\n\n\n\n\n\n","category":"module"},{"location":"parallelstencil/#ParallelStencil.@blockDim-Tuple","page":"ParallelStencil","title":"ParallelStencil.@blockDim","text":"@blockDim()\n\nReturn the block size (or \"dimension\") in x, y and z dimension. The block size in a specific dimension is commonly retrieved directly as in this example in x dimension: @blockDim().x.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@blockIdx-Tuple","page":"ParallelStencil","title":"ParallelStencil.@blockIdx","text":"@blockIdx()\n\nReturn the block ID in x, y and z dimension within the grid. The block ID in a specific dimension is commonly retrieved directly as in this example in x dimension: @blockIdx().x.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@gridDim-Tuple","page":"ParallelStencil","title":"ParallelStencil.@gridDim","text":"@gridDim()\n\nReturn the grid size (or \"dimension\") in x, y and z dimension. The grid size in a specific dimension is commonly retrieved directly as in this example in x dimension: @gridDim().x.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@hide_communication-Tuple","page":"ParallelStencil","title":"ParallelStencil.@hide_communication","text":"@hide_communication boundary_width block\n\nnote: Advanced\n@hide_communication ranges_outer ranges_inner block\n\nHide the communication behind the computation within the code block.\n\nArguments\n\nboundary_width::Tuple{Integer,Integer,Integer} | Tuple{Integer,Integer} | Tuple{Integer}: width of the boundaries in each dimension. The boundaries must include (at least) all the data that is accessed in the communcation performed.\nblock: code block wich starts with exactly one @parallel call to perform computations, followed by code to set boundary conditions and to perform communication (as e.g. update_halo! from the package ImplicitGlobalGrid). The @parallel call to perform computations cannot contain any positional arguments (ranges, nblocks or nthreads) nor the stream keyword argument (stream=...). The code to set boundary conditions and to perform communication must only access the elements in the boundary ranges of the fields modified in the @parallel call; all elements can be acccessed from other fields. Moreover, this code must not include statements in array broadcasting notation, because they are always run on the default CUDA stream (for CUDA.jl < v2.0), which makes CUDA stream overlapping impossible. Instead, boundary region elements can, e.g., be accessed with @parallel calls passing a ranges argument that ensures that no threads mapping to elements outside of ranges_outer are launched. Note that these @parallel ranges calls cannot contain any other positional arguments (nblocks or nthreads) nor the stream keyword argument (stream=...).\n\nnote: Advanced\nranges_outer::Tuple with one or multiple ranges as required by the corresponding argument of @parallel: the ranges must together span (at least) all the data that is accessed in the communcation and boundary conditions performed.\nranges_inner::Tuple with one or multiple ranges as required by the corresponding argument of @parallel: the ranges must together span the data that is not included by ranges_outer.\n\nExamples\n\n@hide_communication (16, 2, 2) begin\n    @parallel diffusion3D_step!(Te2, Te, Ci, lam, dt, dx, dy, dz);\n    update_halo!(Te2);\nend\n\n@hide_communication (16, 2) begin\n    @parallel diffusion2D_step!(Te2, Te, Ci, lam, dt, dx, dy);\n    update_halo!(Te2);\nend\n\n@hide_communication ranges_outer ranges_inner begin\n    @parallel diffusion3D_step!(Te2, Te, Ci, lam, dt, dx, dy, dz);\n    update_halo!(Te2);\nend\n\n@parallel_indices (iy,iz) function bc_x(A)\n    A[  1, iy,  iz] = A[    2,   iy,   iz]\n    A[end, iy,  iz] = A[end-1,   iy,   iz]\n    return\nend\n@parallel_indices (ix,iz) function bc_y(A)\n    A[ ix,  1,  iz] = A[   ix,    2,   iz]\n    A[ ix,end,  iz] = A[   ix,end-1,   iz]\n    return\nend\n@parallel_indices (ix,iy) function bc_z(A)\n    A[ ix,  iy,  1] = A[   ix,   iy,    2]\n    A[ ix,  iy,end] = A[   ix,   iy,end-1]\n    return\nend\n@hide_communication (16, 2, 2) begin\n    @parallel diffusion3D_step!(Te2, Te, Ci, lam, dt, dx, dy, dz);\n    @parallel (1:size(Te,2), 1:size(Te,3)) bc_x(Te);\n    @parallel (1:size(Te,1), 1:size(Te,3)) bc_y(Te);\n    @parallel (1:size(Te,1), 1:size(Te,2)) bc_z(Te);\n    update_halo!(Te2);\nend\n\nnote: Developers note\nThe communcation should not perform any blocking operations to enable a maximal overlap of communication with computation.\n\nSee also: @parallel\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@init_parallel_stencil-Tuple{Any, Any, Any}","page":"ParallelStencil","title":"ParallelStencil.@init_parallel_stencil","text":"@init_parallel_stencil(package, numbertype, ndims)\n\nInitialize the package ParallelStencil, giving access to its main functionality. Creates a module Data in the module where @init_parallel_stencil is called from. The module Data contains the types Data.Number, Data.Array and Data.DeviceArray (type ?Data after calling @init_parallel_stencil to see the full description of the module).\n\nArguments\n\npackage::Module: the package used for parallelization (CUDA or Threads).\nnumbertype::DataType: the type of numbers used by @zeros, @ones and @rand and in all array types of module Data (e.g. Float32 or Float64). It is contained in Data.Number after @initparallelstencil.\nndims::Integer: the number of dimensions used for the stencil computations in the kernels (1, 2 or 3).\n\nSee also: Data\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@ones-Tuple","page":"ParallelStencil","title":"ParallelStencil.@ones","text":"@ones(args...)\n\nCall ones(numbertype, args...), where numbertype is the datatype selected with @init_parallel_stencil and the function ones is chosen to be compatible with the package for parallelization selected with @init_parallel_stencil (ones for Threads CUDA.ones for CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@parallel-Tuple","page":"ParallelStencil","title":"ParallelStencil.@parallel","text":"@parallel kernel\n\nDeclare the kernel parallel and containing stencil computations be performed with one of the submodules ParallelStencil.FiniteDifferences{1D|2D|3D} (or with a compatible custom module or set of macros).\n\nSee also: @init_parallel_stencil\n\n\n\n@parallel kernelcall\n\nnote: Advanced\n@parallel ranges kernelcall\n@parallel nblocks nthreads kernelcall\n@parallel ranges nblocks nthreads kernelcall\n@parallel (...) kwargs... kernelcall\n\nDeclare the kernelcall parallel. The kernel will automatically be called as required by the package for parallelization selected with @init_parallel_stencil. Synchronizes at the end of the call (if a stream is given via keyword arguments, then it synchronizes only this stream).\n\nArguments\n\nkernelcall: a call to a kernel that is declared parallel.\n\nnote: Advanced optional arguments\nranges::Tuple{UnitRange{},UnitRange{},UnitRange{}} | Tuple{UnitRange{},UnitRange{}} | Tuple{UnitRange{}} | UnitRange{}: the ranges of indices in each dimension for which computations must be performed.\nnblocks::Tuple{Integer,Integer,Integer}: the number of blocks to be used if the package CUDA was selected with @init_parallel_stencil.\nnthreads::Tuple{Integer,Integer,Integer}: the number of threads to be used if the package CUDA was selected with @init_parallel_stencil.\nkwargs...: keyword arguments to be passed further to CUDA (ignored for Threads).\n\nnote: Performance note\nKernel launch parameters are automatically defined with heuristics, where not defined with optional kernel arguments. For CUDA nthreads is whenever reasonable set to (32,8,1) and nblocks accordingly to ensure that enough threads are launched.\n\nSee also: @init_parallel_stencil\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@parallel_async-Tuple","page":"ParallelStencil","title":"ParallelStencil.@parallel_async","text":"@parallel_async kernelcall\n\nnote: Advanced\n@parallel_async ranges kernelcall\n@parallel_async nblocks nthreads kernelcall\n@parallel_async ranges nblocks nthreads kernelcall\n@parallel_async (...) kwargs... kernelcall\n\nDeclare the kernelcall parallel as with @parallel (see @parallel for more information); deactivates however automatic synchronization at the end of the call. Use @synchronize for synchronizing.\n\nnote: Performance note\n@parallelasync falls currently back to running synchronously if the package Threads was selected with [`@initparallel_stencil`](@ref).\n\nSee also: @synchronize, @parallel\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@parallel_indices-Tuple","page":"ParallelStencil","title":"ParallelStencil.@parallel_indices","text":"@parallel_indices indices kernel\n\nDeclare the kernel parallel and generate the given parallel indices inside the kernel using the package for parallelization selected with @init_parallel_stencil.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@ps_println-Tuple","page":"ParallelStencil","title":"ParallelStencil.@ps_println","text":"@ps_println(...)\n\nCall a macro analogue to Base.@println, compatible with the package for parallelization selected with @init_parallel_stencil (Base.@println for Threads and CUDA.@cuprintln for CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@ps_show-Tuple","page":"ParallelStencil","title":"ParallelStencil.@ps_show","text":"@ps_show(...)\n\nCall a macro analogue to Base.@show, compatible with the package for parallelization selected with @init_parallel_stencil (Base.@show for Threads and CUDA.@cushow for CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@rand-Tuple","page":"ParallelStencil","title":"ParallelStencil.@rand","text":"@rand(args...)\n\nCall rand(numbertype, args...), where numbertype is the datatype selected with @init_parallel_stencil and the function rand is chosen/implemented to be compatible with the package for parallelization selected with @init_parallel_stencil.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@reset_parallel_stencil-Tuple{}","page":"ParallelStencil","title":"ParallelStencil.@reset_parallel_stencil","text":"@reset_parallel_stencil()\n\nReset the ParallelStencil module.\n\nSee also: init_parallel_stencil\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@sharedMem-Tuple","page":"ParallelStencil","title":"ParallelStencil.@sharedMem","text":"@sharedMem(T, dims)\n\nCreate an array that is shared between the threads of a block (i.e. accessible only by the threads of a same block), with element type T and size specified by dims.\n\nnote: Note\nThe amount of shared memory needs to specified when launching the kernel (keyword argument shmem).\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@sync_threads-Tuple","page":"ParallelStencil","title":"ParallelStencil.@sync_threads","text":"@sync_threads()\n\nSynchronize the threads of the block: wait until all threads in the block have reached this point and all global and shared memory accesses made by these threads prior to the sync_threads() call are visible to all threads in the block.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@synchronize-Tuple","page":"ParallelStencil","title":"ParallelStencil.@synchronize","text":"@synchronize()\n\nSynchronize the GPU/CPU.\n\nSee also: @parallel_async\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@threadIdx-Tuple","page":"ParallelStencil","title":"ParallelStencil.@threadIdx","text":"@threadIdx()\n\nReturn the thread ID in x, y and z dimension within the block. The thread ID in a specific dimension is commonly retrieved directly as in this example in x dimension: @threadIdx().x.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@zeros-Tuple","page":"ParallelStencil","title":"ParallelStencil.@zeros","text":"@zeros(args...)\n\nCall zeros(numbertype, args...), where numbertype is the datatype selected with @init_parallel_stencil and the function zeros is chosen to be compatible with the package for parallelization selected with @init_parallel_stencil (zeros for Threads and CUDA.zeros for CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"eigenvalue-problem/#Eigenvalue-Problem","page":"Eigenvalue Problem","title":"Eigenvalue Problem","text":"","category":"section"},{"location":"eigenvalue-problem/#Approximation-of-eigenvalues","page":"Eigenvalue Problem","title":"Approximation of eigenvalues","text":"","category":"section"},{"location":"eigenvalue-problem/#Gershgorin's-theorem","page":"Eigenvalue Problem","title":"Gershgorin's theorem","text":"","category":"section"},{"location":"eigenvalue-problem/","page":"Eigenvalue Problem","title":"Eigenvalue Problem","text":"Papadrakakis, 1981","category":"page"},{"location":"stiffness-of-pdes/#Stiffness-of-PDEs","page":"Stiffness of PDEs","title":"Stiffness of PDEs","text":"","category":"section"},{"location":"stiffness-of-pdes/#Approaches","page":"Stiffness of PDEs","title":"Approaches","text":"","category":"section"},{"location":"stiffness-of-pdes/#Operator-splitting","page":"Stiffness of PDEs","title":"Operator splitting","text":"","category":"section"},{"location":"stiffness-of-pdes/","page":"Stiffness of PDEs","title":"Stiffness of PDEs","text":"separate the system of PDEs into two parts\ni). Non-stiff part: first system which contains only hyperbolic operators\nii). Stiff part: second system which contains parabolic operators ('stiff'), solved independently from the first system at each time step.\ndifferent orders for various approaches\na). 1st order (Godunov-type)\nb). 2nd order (Strang splitting)\nc). other higher order splitting...\nconvergence requirements\nsmoothness of the solution of the system of PDEs","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/#[GLMakie.jl](https://github.com/MakieOrg/Makie.jl)","page":"Visualization","title":"GLMakie.jl","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In case one is using Intel GPU and cannot make GLMakie to compile correctly, we may need to check if the needed libraries are linked correctly. More see this Github Issue","category":"page"},{"location":"methodology/#Methodology","page":"Methodology","title":"Methodology","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The methodology differs in the multiphysics coupling","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"i). Fully coupled modelassuming lithostatic total pressure gradient => decoupling of the fluid flow from shear deformation\nprediction of stresses and pressure distribution in the porous matrix (geomechanics)","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Benifit 1: Total pressure does not follow a lithostatic gradient?\nBenifit 2: The shear deformation of the porous matrix is resolved?","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"a). Direct coupling (Industry-related simulator)","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"fluid pressure is transferred to the geomechanical module, but the geomechanics do not impact the fluid pressure","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"b). Iterative coupling","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"iterative coupling of the fluid-flow solver to a geomechanical solver","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"c). Single solver","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"fully coupling of the fluid flow and the Stokes matrix flow within a single solver","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"ii). Decompaction weakening model  decompaction weakening while coupling Darcian and Stokes flows in 3-D","category":"page"},{"location":"methodology/#Decompaction-weakening-[Räss-et-al.-(2019)](https://doi.org/10.1093/gji/ggz239)","page":"Methodology","title":"Decompaction weakening Räss et al. (2019)","text":"","category":"section"},{"location":"methodology/#Motivation","page":"Methodology","title":"Motivation","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"study of various phenomena of porous fluids (fingering, veining, channeling and focussing)\nstructure: subseabed pipes (eg. on the Nigerian continental shelf and in the Norwegian North Sea) \nmay act as preferential fluid pathways. Understanding how these pipes are formed and evolved can help us to accurately constrain subsurface fluid flow","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"[] What is the delocalization of the patterns of the flow?","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Experiences:  flow patterns are localized, induced by fractures\nTheory:  using classical Darcian model, diffusive behavior is expected => leads to never-ending spreading and delocalization","category":"page"},{"location":"methodology/#What-is-the-decompaction-weakening?","page":"Methodology","title":"What is the decompaction weakening?","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"corresponds to high eta_d value","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The degree of the decompaction weakening can be quantitatively determined by the quotient of the compaction bulk viscosity eta_c and its decompaction counterpart eta_d.","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"R = fraceta_ceta_d","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Decompaction is significant R  1 => flow channeling\nwhen R=1 we have blob-like porosity waves","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The effective pressure P_e can be used to monitor the compaction within a certain region.","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Region in compaction P_e  0\nRegion in decompaction P_e  0","category":"page"},{"location":"methodology/#Mathematical-model","page":"Methodology","title":"Mathematical model","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Bulk viscosity","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"eta_phi = eta_c fracphi_0phi 1 + frac12 (frac1R - 1)(1 + tanh -fracp_elambda_p)","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"(Image: tanh_smoothing)","category":"page"},{"location":"methodology/#Numerical-experiment","page":"Methodology","title":"Numerical experiment","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Media:  fluid-saturated\nObjective:  observation of the flow patterns \nlocalized, delocalized?\nformation?\npropagation?","category":"page"},{"location":"methodology/#Numerical-methods","page":"Methodology","title":"Numerical methods","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The PT-method used in Räss et al. added the non-linear residual terms f_v f_p^t f_p^f to 3 of the governing equations and aims to obtain the solution by minimizing the residuals iteratively within a pseudo-time loop","category":"page"},{"location":"methodology/#Results","page":"Methodology","title":"Results","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Decompaction weaknening","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"3x-higher fluid-flow rate than the pure Darcy model","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/#Porosity-wave-benchmark","page":"Benchmarks","title":"Porosity wave benchmark","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Using the decompaction weakening approach as in Raess et al.. We set up the benchmark for the porosity wave regime as limit of two-phase flow. The goal of this benchmark is to verify the reproducibility of the methodology as described here","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[  ] DI versus PT (2D)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[  ] numerical vs. exact analytical solutions of solitary waves (1D)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[  ] convergence study with varying spatial and temporal resolutions (2D)","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Resulting animation of the code provided in the HydroMech2D.jl, which is the starting point of our implementation of the solver.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"R=500, t=0.02","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: 2D wave)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"R=1.0, t=0.2","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: 2D wave)","category":"page"},{"location":"benchmarks/#Fluid-injection-2D-benchmark","page":"Benchmarks","title":"Fluid injection 2D benchmark","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Reproduce fluid injection 2D benchmark in Luca et al. 2022","category":"page"},{"location":"performance/#Improving-the-source-code","page":"Performance","title":"Improving the source code","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"# without visualization\nit = 1530, time = 5.027e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1531, time = 4.839e-01 sec (@ T_eff = 24.00 GB/s) \nit = 1532, time = 4.861e-01 sec (@ T_eff = 24.00 GB/s) \nit = 1533, time = 5.011e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1534, time = 4.852e-01 sec (@ T_eff = 24.00 GB/s) \nit = 1535, time = 5.018e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1536, time = 4.849e-01 sec (@ T_eff = 24.00 GB/s) ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# with visualization\nit = 1530, time = 5.132e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1531, time = 5.105e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1532, time = 5.286e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1533, time = 5.123e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1534, time = 5.308e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1535, time = 5.107e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1536, time = 5.233e-01 sec (@ T_eff = 22.00 GB/s) ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"After some basic HPC-driven code improvement while making sure all the reference tests passed, the original 2D code has the following performance","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# without visualization\nit = 1530, time = 4.946e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1531, time = 5.352e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1532, time = 4.941e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1533, time = 4.940e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1534, time = 5.163e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1535, time = 4.942e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1536, time = 4.942e-01 sec (@ T_eff = 23.00 GB/s) ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# with visualization\nit = 1530, time = 4.619e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1531, time = 4.601e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1532, time = 4.899e-01 sec (@ T_eff = 24.00 GB/s) \nit = 1533, time = 4.594e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1534, time = 4.651e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1535, time = 4.665e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1536, time = 4.837e-01 sec (@ T_eff = 24.00 GB/s) ","category":"page"},{"location":"performance/#Distributed-Computing","page":"Performance","title":"Distributed Computing","text":"","category":"section"},{"location":"performance/#Tutorial","page":"Performance","title":"Tutorial","text":"","category":"section"},{"location":"performance/#Simple-Performance-Estimation","page":"Performance","title":"Simple Performance Estimation","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"We can estimate the performance using the following metrics ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"T_texteff = fracA_textefft_textit = frac2 D_u + D_kDelta t  textniter","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"TODO: add the example of the effective memory","category":"page"},{"location":"performance/#Parallelizing-a-serial-code","page":"Performance","title":"Parallelizing a serial code","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"STEP 1: Precompute scalars, remove divisions","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# instead of division, we precompute the fractions to be multipled on\n_β_dτ_D     = 1. /β_dτ_D","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"STEP 2: Remove element-wise operators and use loops instead for updating the elements of the arrays, where we introduce the indices like ix, iy","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# the pressure update using the element-wise arithmetic operations\nPf     .-= ((qDx[2:end, :] - qDx[1:end-1, :]).* _dx .+ (qDy[:, 2:end] - qDy[:, 1:end-1]).* _dy).* _β_dτ_D","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"STEP 3: Remove the julia functions like diff(A, dims=1) and use the indices ix, iy instead to \"manually\" compute the differences. Another possibility is to use the macros of the ParallelStencil package by @d_xa, @d_ya etc","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# we manually implemented the macros\nmacro d_xa(A)  esc(:( $A[ix+1,iy]-$A[ix,iy] )) end\nmacro d_ya(A)  esc(:( $A[ix,iy+1]-$A[ix,iy] )) end\n\n# and use them for the loop version of differences calculation\nPf[ix,iy]     -= (@d_xa(qDx) * _dx + @d_ya(qDy)* _dy) * _β_dτ_D\n","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"STEP 4: After verifying the correctness of the bounds to be iterated on, add the macro @inbounds at the needed places\nSTEP 5: Move the loops into a compute kernel in the following forms","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"function compute_Pf!(Pf,...)\n    nx, ny = size(Pf)\n    ...\n    return nothing\nend","category":"page"},{"location":"performance/#Parallelizing-using-ParallelStencil.jl","page":"Performance","title":"Parallelizing using ParallelStencil.jl","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"For the macros that can be used, check the FiniteDifferences.jl","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"\nusing Printf, LazyArrays, Plots, BenchmarkTools\nusing JLD  # for storing testing data\n\n\n@views av1(A) = 0.5.*(A[1:end-1].+A[2:end])\n@views avx(A) = 0.5.*(A[1:end-1,:].+A[2:end,:])\n@views avy(A) = 0.5.*(A[:,1:end-1].+A[:,2:end])\n\n\nmacro d_xa(A)  esc(:( $A[ix+1,iy]-$A[ix,iy] )) end\nmacro d_ya(A)  esc(:( $A[ix,iy+1]-$A[ix,iy] )) end\n\n\n\n# Darcy's flux update\nfunction compute_flux_darcy!(Pf, T, qDx, qDy, _dx, _dy, k_ηf, αρgx, αρgy, _1_θ_dτ_D)\n    nx, ny = size(Pf)\n\n    for iy = 1:ny\n        for ix = 1:nx-1\n            # qDx[2:end-1,:] .-= (qDx[2:end-1,:] .+ k_ηf.*((Pf[2:end,:] .- Pf[1:end-1, :]) .* _dx .- αρgx.*avx(T))).* _1_θ_dτ_D\n            qDx[ix+1,iy] -= (qDx[ix+1,iy] + k_ηf * (@d_xa(Pf) * _dx - αρgx *  0.5 * (T[ix,iy] + T[ix+1,iy]))) * _1_θ_dτ_D\n            \n        end\n    end\n    \n    for iy = 1:ny-1\n        for ix = 1:nx\n            # qDy[:,2:end-1] .-= (qDy[:,2:end-1] .+ k_ηf.*((Pf[:, 2:end] .- Pf[:, 1:end-1]) .* _dy .- αρgy.*avy(T))).* _1_θ_dτ_D\n            qDy[ix,iy+1] -= (qDy[ix,iy+1] + k_ηf * (@d_ya(Pf) * _dy - αρgy * 0.5 * (T[ix, iy] + T[ix, iy+1]))) * _1_θ_dτ_D\n        end\n    end\n\nend\n\n\n# pressure update\nfunction compute_Pf!(Pf, qDx, qDy, _dx, _dy, _β_dτ_D)\n    nx, ny = size(Pf)\n\n    for iy = 1:ny\n        for ix = 1:nx\n            # Pf     .-= ((qDx[2:end, :] - qDx[1:end-1, :]).* _dx .+ (qDy[:, 2:end] - qDy[:, 1:end-1]).* _dy).* _β_dτ_D\n            @inbounds Pf[ix,iy]     -= (@d_xa(qDx) * _dx + @d_ya(qDy)* _dy) * _β_dτ_D\n        end\n    end\n\n    return nothing\nend\n\n\nfunction compute_flux_temp!(Pf, T, qTx, qTy, _dx, _dy, λ_ρCp, _1_θ_dτ_T)\n    nx, ny = size(Pf)\n\n    for iy = 1:ny-2\n        for ix = 1:nx-1\n            # qTx            .-= (qTx .+ λ_ρCp.*(Diff(T[:,2:end-1],dims=1)./dx))./(1.0 + θ_dτ_T)\n            qTx[ix,iy]  -= (qTx[ix,iy] + λ_ρCp*(@d_xa(T[:,2:end-1])* _dx)) * _1_θ_dτ_T                    \n        end\n    end\n    \n    for iy = 1:ny-1\n        for ix = 1:nx-2\n            # qTy            .-= (qTy .+ λ_ρCp.*(Diff(T[2:end-1,:],dims=2)./dy))./(1.0 + θ_dτ_T)\n            qTy[ix,iy]  -= (qTy[ix,iy] + λ_ρCp*(@d_ya(T[2:end-1,:])* _dy)) * _1_θ_dτ_T\n        end\n    end\n\nend\n\n\n\nfunction compute_T!(T, dTdt, qTx, qTy, _dx, _dy, _dt_β_dτ_T)\n    nx, ny = size(T)\n\n    for iy = 1:ny-2\n        for ix = 1:nx-2\n            # T[2:end-1,2:end-1] .-= (dTdt .+ @d_xa(qTx).* _dx .+ @d_ya(qTy).* _dy).* _dt_β_dτ_T\n            T[ix+1,iy+1] -= (dTdt[ix,iy] + @d_xa(qTx)* _dx + @d_ya(qTy)* _dy)* _dt_β_dτ_T                    \n        end\n    end\nend\n\n\n\n@views function porous_convection_2D_xpu(ny_, nt_; do_visu=false, do_check=true, test=true)\n    # physics\n    lx,ly       = 40., 20.\n    k_ηf        = 1.0\n    αρgx,αρgy   = 0.0,1.0\n    αρg         = sqrt(αρgx^2+αρgy^2)\n    ΔT          = 200.0\n    ϕ           = 0.1\n    Ra          = 1000                    # changed from 100\n    λ_ρCp       = 1/Ra*(αρg*k_ηf*ΔT*ly/ϕ) # Ra = αρg*k_ηf*ΔT*ly/λ_ρCp/ϕ\n  \n    # numerics\n    ny          = ny_                     # ceil(Int,nx*ly/lx)\n    nx          = 2 * (ny+1) - 1          # 127\n    nt          = nt_                     # 500\n    re_D        = 4π\n    cfl         = 1.0/sqrt(2.1)\n    maxiter     = 10max(nx,ny)\n    ϵtol        = 1e-6\n    nvis        = 20\n    ncheck      = ceil(max(nx,ny)) # ceil(0.25max(nx,ny))\n  \n    # preprocessing\n    dx,dy       = lx/nx,ly/ny\n    xn,yn       = LinRange(-lx/2,lx/2,nx+1),LinRange(-ly,0,ny+1)\n    xc,yc       = av1(xn),av1(yn)\n    θ_dτ_D      = max(lx,ly)/re_D/cfl/min(dx,dy)\n    β_dτ_D      = (re_D*k_ηf)/(cfl*min(dx,dy)*max(lx,ly))\n   \n    # hpc value precomputation\n    _dx, _dy    = 1. /dx, 1. /dy\n    _ϕ          = 1. / ϕ\n    _1_θ_dτ_D   = 1 ./(1.0 + θ_dτ_D)\n    _β_dτ_D     = 1. /β_dτ_D\n\n\n    # array initialization\n    Pf          = zeros(nx,ny)\n    r_Pf        = zeros(nx,ny)\n    qDx,qDy     = zeros(nx+1,ny),zeros(nx,ny+1)\n    qDx_c,qDy_c = zeros(nx,ny),zeros(nx,ny)\n    qDmag       = zeros(nx,ny)     \n    T           = @. ΔT*exp(-xc^2 - (yc'+ly/2)^2); T[:,1] .= ΔT/2; T[:,end] .= -ΔT/2\n    T_old       = copy(T)\n    dTdt        = zeros(nx-2,ny-2)\n    r_T         = zeros(nx-2,ny-2)\n    qTx         = zeros(nx-1,ny-2)\n    qTy         = zeros(nx-2,ny-1)\n   \n    st          = ceil(Int,nx/25)\n    Xc, Yc      = [x for x=xc, y=yc], [y for x=xc,y=yc]\n    Xp, Yp      = Xc[1:st:end,1:st:end], Yc[1:st:end,1:st:end]\n\n    # visu\n    if do_visu\n        # needed parameters for plotting\n\n        # plotting environment\n        ENV[\"GKSwstype\"]=\"nul\"\n        if isdir(\"viz_out\")==false mkdir(\"viz_out\") end\n        loadpath = \"viz_out/\"; anim = Animation(loadpath,String[])\n        println(\"Animation directory: $(anim.dir)\")\n        iframe = 0\n    end\n\n\n\n    # action\n    t_tic = 0.0; niter = 0\n    for it = 1:nt\n        T_old .= T\n\n        # time step\n        dt = if it == 1 \n            0.1*min(dx,dy)/(αρg*ΔT*k_ηf)\n        else\n            min(5.0*min(dx,dy)/(αρg*ΔT*k_ηf),ϕ*min(dx/maximum(abs.(qDx)), dy/maximum(abs.(qDy)))/2.1)\n        end\n\n        _dt = 1. /dt   # precomputation\n        \n        \n        re_T    = π + sqrt(π^2 + ly^2/λ_ρCp * _dt)\n        θ_dτ_T  = max(lx,ly)/re_T/cfl/min(dx,dy)\n        β_dτ_T  = (re_T*λ_ρCp)/(cfl*min(dx,dy)*max(lx,ly))\n        \n        _1_θ_dτ_T   = 1 ./ (1.0 + θ_dτ_T)\n        _dt_β_dτ_T  = 1 ./(_dt + β_dτ_T) # precomputation\n\n        # iteration loop\n        iter = 1; err_D = 2ϵtol; err_T = 2ϵtol\n        while max(err_D,err_T) >= ϵtol && iter <= maxiter\n            if (it==1 && iter == 11) t_tic = Base.time(); niter=0 end\n\n            # hydro            \n            compute_flux_darcy!(Pf, T, qDx, qDy, _dx, _dy, k_ηf, αρgx, αρgy, _1_θ_dτ_D)\n            compute_Pf!(Pf, qDx, qDy, _dx, _dy, _β_dτ_D)\n            \n            # thermo\n            compute_flux_temp!(Pf, T, qTx, qTy, _dx, _dy, λ_ρCp, _1_θ_dτ_T)\n            #     dTdt        = zeros(nx-2,ny-2)\n            \n\n            dTdt           .= (T[2:end-1,2:end-1] .- T_old[2:end-1,2:end-1]).* _dt .+\n                                (max.(qDx[2:end-2,2:end-1],0.0).*Diff(T[1:end-1,2:end-1],dims=1).* _dx .+\n                                 min.(qDx[3:end-1,2:end-1],0.0).*Diff(T[2:end  ,2:end-1],dims=1).* _dx .+\n                                 max.(qDy[2:end-1,2:end-2],0.0).*Diff(T[2:end-1,1:end-1],dims=2).* _dy .+\n                                 min.(qDy[2:end-1,3:end-1],0.0).*Diff(T[2:end-1,2:end  ],dims=2).* _dy).* _ϕ\n\n            \n            # for iy = 1:ny-2\n            #     for ix = 1:nx-2\n            #         dTdt[ix,iy]           = (T[ix+1,iy+1] - T_old[ix+1,iy+1]) * _dt +\n            #         (max(qDx[2:end-2,2:end-1],0.0) * @d_xa(T[1:end-1,2:end-1]) * _dx  +\n            #          min(qDx[3:end-1,2:end-1],0.0) * @d_xa(T[2:end  ,2:end-1]) * _dx  +\n            #          max(qDy[2:end-1,2:end-2],0.0) * @d_ya(T[2:end-1,1:end-1]) * _dy  +\n            #          min(qDy[2:end-1,3:end-1],0.0) * @d_ya(T[2:end-1,2:end  ]) * _dy) * _ϕ\n\n            #     end\n            # end\n            \n            compute_T!(T, dTdt, qTx, qTy, _dx, _dy, _dt_β_dτ_T)\n\n\n            # TODO: add the boundary condition kernel afterwards\n            # Boundary condition\n            T[[1,end],:]        .= T[[2,end-1],:]\n\n\n            if do_check && iter % ncheck == 0\n                r_Pf  .= Diff(qDx,dims=1).* _dx .+ Diff(qDy,dims=2).* _dy\n                r_T   .= dTdt .+ Diff(qTx,dims=1).* _dx .+ Diff(qTy,dims=2).* _dy\n                err_D  = maximum(abs.(r_Pf))\n                err_T  = maximum(abs.(r_T))\n                # @printf(\"  iter/nx=%.1f, err_D=%1.3e, err_T=%1.3e\\n\",iter/nx,err_D,err_T)\n            end\n            iter += 1; niter += 1\n        end\n        # @printf(\"it = %d, iter/nx=%.1f, err_D=%1.3e, err_T=%1.3e\\n\",it,iter/nx,err_D,err_T)\n\n        if it % nvis == 0\n            qDx_c .= avx(qDx)\n            qDy_c .= avy(qDy)\n            qDmag .= sqrt.(qDx_c.^2 .+ qDy_c.^2)\n            qDx_c ./= qDmag\n            qDy_c ./= qDmag\n            qDx_p = qDx_c[1:st:end,1:st:end]\n            qDy_p = qDy_c[1:st:end,1:st:end]\n            \n\n            # visualisation\n            if do_visu\n                heatmap(xc,yc,T';xlims=(xc[1],xc[end]),ylims=(yc[1],yc[end]),aspect_ratio=1,c=:turbo)\n                png(quiver!(Xp[:], Yp[:], quiver=(qDx_p[:], qDy_p[:]), lw=0.5, c=:black),\n                    @sprintf(\"viz_out/porous2D_%04d.png\",iframe+=1))\n            end\n        end\n\n    end\n\n\n    t_toc = Base.time() - t_tic\n    # FIXME: change the expression to compute the effective memory throughput!\n    A_eff = (3 * 2) / 1e9 * nx * ny * sizeof(Float64)  # Effective main memory access per iteration [GB]\n    t_it  = t_toc / niter                              # Execution time per iteration [s]\n    T_eff = A_eff / t_it                               # Effective memory throughput [GB/s]\n    \n    @printf(\"Time = %1.3f sec, T_eff = %1.3f GB/s \\n\", t_toc, T_eff)\n\n\n    if test == true\n        save(\"../test/qDx_p_ref_30_2D.jld\", \"data\", qDx_c[1:st:end,1:st:end])  # store case for reference testing\n        save(\"../test/qDy_p_ref_30_2D.jld\", \"data\", qDy_c[1:st:end,1:st:end])\n    end\n    \n    # Return qDx_p and qDy_p at final time\n    return [qDx_c[1:st:end,1:st:end], qDy_c[1:st:end,1:st:end]]   \nend\n\n\n\nif isinteractive()\n    porous_convection_2D_xpu(63, 500; do_visu=false, do_check=true,test=false)  # ny = 63\nend\n\n\n","category":"page"},{"location":"dispersion-analysis/#Dispersion-Analysis","page":"Dispersion Analysis","title":"Dispersion Analysis","text":"","category":"section"},{"location":"dispersion-analysis/","page":"Dispersion Analysis","title":"Dispersion Analysis","text":"Using the tools from dispersion analysis, we can analyze the number of iterations required to reach convergence given equations prescribing a physical process.","category":"page"},{"location":"dispersion-analysis/#Numerical-dispersion","page":"Dispersion Analysis","title":"Numerical dispersion","text":"","category":"section"},{"location":"dispersion-analysis/","page":"Dispersion Analysis","title":"Dispersion Analysis","text":"Numerical dispersion: a difficulty with computer simulations of continua (such as fluids) wherein the simulated medium exhibits a higher dispersivity than the true medium. wikipedia","category":"page"},{"location":"timeline/#Timeline","page":"Time line","title":"Timeline","text":"","category":"section"},{"location":"timeline/","page":"Time line","title":"Time line","text":"This is a small timeline including the ","category":"page"},{"location":"timeline/","page":"Time line","title":"Time line","text":"Datum Content Current goals / Todos\nOct. 25 overview of the JustRelax.jl package, setting goals for the julia course roadmap is provided via hackmd\nNov. 28 Meeting settle the repository structure, current goal focuses on the reproducing the 2D porosity wave benchmark, the implementation of the compressible term and the fluid injection benchmark\nNov. 29 Julia course project week 1 \nunscheduled Meeting \nDec. 6 Julia course project week 2 \nunscheduled Meeting \nDec. 13 Julia course project week 3 \nunscheduled Meeting \nDec. 22 project report deadline for the course 101-0250-00L ","category":"page"},{"location":"iteration-parameters/#Iteration-Parameters","page":"Iteration Parameters","title":"Iteration Parameters","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"The choice of the iteration parameters are essential for the accelerated PT method as the method is highly sensitive to it.","category":"page"},{"location":"iteration-parameters/#Choice-of-iteration-parameters","page":"Iteration Parameters","title":"Choice of iteration parameters","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"Generally, the values of the iteration parameters are associated with the maximum eigenvalue of the stiffness matrix.","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"The optimal iteration parameters for a variety of basic physical processes can be determined analytically but for most of the practical problems the eigenvalue problem needs to be solved.","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"For the eigenvalue problem see more about its numerical aspects here.","category":"page"},{"location":"iteration-parameters/#Factor-1:-Choice-of-the-B.C.","page":"Iteration Parameters","title":"Factor 1:  Choice of the B.C.","text":"","category":"section"},{"location":"iteration-parameters/#Factor-2:-Numerical-stability-restriction","page":"Iteration Parameters","title":"Factor 2:  Numerical stability restriction","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"for explicit time integration, the size of the timesteps is upper-bounded","category":"page"},{"location":"iteration-parameters/#Case-studies","page":"Iteration Parameters","title":"Case studies","text":"","category":"section"},{"location":"iteration-parameters/#Physical-processes","page":"Iteration Parameters","title":"Physical processes","text":"","category":"section"},{"location":"iteration-parameters/#).-Diffusion","page":"Iteration Parameters","title":"1). Diffusion","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"rho fracpartial Hpartial t = -nabla_k q_k","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"q_i = -D nabla_k H i = 1 n_d","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"Or by plugging the second equation into the first one we obtained a single equation for describing the diffusive process.","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"rho fracpartial Hpartial t = nabla_k (D nabla_k H)","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"H ↔ some physical quantity\nD ↔ diffusion coefficient \nρ ↔ proportionality coefficient\nt ↔ physical time","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"The stationary diffuion process is given by the above equation when fracpartial Hpartial trightarrow 0","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"0 = nabla_k (D nabla_k H)","category":"page"},{"location":"iteration-parameters/#Applying-PT-method","page":"Iteration Parameters","title":"Applying PT method","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"For the accelerated PT method we do the following:","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"STEP 1: add the inertia term theta_r fracpartial q_ipartial tau to the LHS of the first equation\nSTEP 2: plug the obtained equation from step 1 into the equation 2 to obtain the damped wave equation.\nPDE type switch from parabolic to hyperbolic\ndescribes also wave propagation","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"tilderho theta_r fracpartial^2 Hpartial t^2 + tilderho fracpartial Hpartial tau = nabla_k (D nabla_k H)","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"STEP 3: find the optimal Reynolds number\nRe = fractilderhoV_p LD\n, where V_p = sqrtfracDtilderho theta_r is the finite speed of the information signal of the wave propagation.\nThis can be done by the dispersion analysis, the optimal value of Re in this case is Re_textopt = 2 pi","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"STEP 4: obtain the optimal parameters of tilderho theta_r using the optimal Reynolds number \nGenerally: \"Low Re ⇒ flows tend to be laminar\" and \"High Re ⇒ flows tend to be turbulent\"","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"tilderho = Re fracDtildeVL","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"theta_r = fracDtilderho tildeV^2 = fracLRe tildeV","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"Here we need to solve for V_p = tildeV, where tildeV = fractildeCDelta xDelta tau is the numerical velocity we just introduced. Note that tildeC approx 095 C is used here, which is an emperically determined parameter deduced from numerical experiments.","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"In case D = D(x_k) is not constant, we need to determine its values locally to each grid point. For particularly discontinuous distribution of D, taking a local maximum of D between two neighbouring grid cells for determining the iteration parameters shall be sufficient. Räss et al ","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"STEP 5: perform explicit time stepping","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"Restriction for the size of the pseudo timestep damped wave equation: Delta tau leq fracCV_p Delta x, where Delta x = fracLn_x, value of the non-dimensional number C is determined for the linearised problem (von Neumann stability analysis)","category":"page"},{"location":"iteration-parameters/#Results","page":"Iteration Parameters","title":"Results","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"The number of iterations required for the method to converge is linearly dependent on the numrical grid resolution n_x","category":"page"},{"location":"justrelax-Miniapps/#Miniapps","page":"Miniapps","title":"Miniapps","text":"","category":"section"},{"location":"justrelax-Miniapps/#Stages","page":"Miniapps","title":"7 Stages","text":"","category":"section"},{"location":"justrelax-Miniapps/","page":"Miniapps","title":"Miniapps","text":"In the following section we introduce the structure of the main function of an \"Application\" code","category":"page"},{"location":"justrelax-Miniapps/","page":"Miniapps","title":"Miniapps","text":"Quantities needed to describe \"where the problem lives\", in terms of (parallel) topology\nInitialize tools which can represent this domain concretely in parallel (IGG here, could be PETSc/DM)\nConcrete representations of data and population of values\nIncludes information on embedding/coordinates\nTools, dependent on the data representation, to actually solve a particular physical problem (here JustRelax.jl, but could be PETSc's SNES)\nNote that here, the physical timestepping scheme is baked into this \"physical problem\"\nAnalysis and output which depends on the details of the solver\n\"Application\" Analysis and output which does not depend on the details of the solver\nFinalization/Cleanup","category":"page"},{"location":"justrelax-Miniapps/","page":"Miniapps","title":"Miniapps","text":"In a real application, steps 4., 5., and 6. will likely be repeated multiple times and be interspersed with other logic (e.g. a particle advection step).","category":"page"},{"location":"justrelax-Miniapps/","page":"Miniapps","title":"Miniapps","text":"Note: CompGrids.jl combines 1. 2., and part of 3. (coordinates, and the identity of the fields)","category":"page"},{"location":"justrelax-modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"First phase for Julia's course:","category":"page"},{"location":"roadmap/#Preparation","page":"Roadmap","title":"Preparation","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ x ] Re-run the code of Sidney and make sure it runs fine\n[ x ] Generate some figures\n[ ] Add comments on the code where you have questions or something is unclear\n[ ] Try to change the setup and try to reproduce the porosity wave benchmark as in Raess et al.","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"Please notice that in Raess et al. paper there is a open-source matlab version. You can always use that one to compare the two codes.","category":"page"},{"location":"roadmap/#Implementation","page":"Roadmap","title":"Implementation","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Add compressibility terms to two-phase flow equations\n[ ] Reproduce fluid injection 2D benchmark in Luca et al. 2022","category":"page"},{"location":"roadmap/#Further-goals","page":"Roadmap","title":"Further goals","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Add inertial term to Stokes equations\n[ ] Benchmark (any refs for this?)\n[ ] Move to 3D","category":"page"},{"location":"von-neumann-stability-analysis/#Von-Neumann-Stability-Analysis","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"","category":"section"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"also called as Fourier stability analysis\na procesure used to check the stability of FD schemes when applied to linear PDEs\nbased on the Fourier decomposition of numerical error","category":"page"},{"location":"von-neumann-stability-analysis/#Example-1:-Upper-bound-for-the-\\Delta-\\tau-in-explicit-time-stepping-scheme","page":"Von Neumann Stability Analysis","title":"Example 1: Upper-bound for the Delta tau in explicit time stepping scheme","text":"","category":"section"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"For the damped wave equation when we want to solve it using the PT method, we need to hold to restrictions for parameters if the explicit time stepping scheme is used.","category":"page"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"The upper-bound is given as ","category":"page"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"Delta tau leq fracCV_p Delta x","category":"page"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"Where the non-dimensional number C approx frac1sqrtn_d can be determined using Von Neumann stability analysis, where n_d is the number of spatial dimensions. (Alkhimenkov et al., 2021)","category":"page"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"NOTE: for implicit time stepping scheme of the wave equations, the restriction on the time step vanishes, the time step will be determined by the scheme for Darcy's flux. In case also the implicit scheme is used for the Darcy's flux, the whole scheme will be unconditionally syable.","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#No-solutions-after-certain-iteration-count","page":"Troubleshooting","title":"No solutions after certain iteration count","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Status","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"[ ] Resolved ","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Using the 2D Hydro-mechanical solver for small R values, solution cannot be correctly plotted after a certain state has been reached. The solution can be correctly plotted until the 48th frame (included) as followed.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Description","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"R=0.5, t=0.2","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"(Image: 2D wave)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Where at the 48th frame the distribution of the parameters looks as followed","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"(Image: 2D wave)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"it = 1138, time = 3.307e-02 sec (@ T_eff = 24.00 GB/s) \nit = 1139, time = 3.316e-02 sec (@ T_eff = 24.00 GB/s) \nit = 1140, time = 3.313e-02 sec (@ T_eff = 24.00 GB/s) \nGKS: Rectangle definition is invalid in routine SET_WINDOW\nGKS: Rectangle definition is invalid in routine CELLARRAY\ninvalid range\nGKS: Rectangle definition is invalid in routine SET_WINDOW\nGKS: Rectangle definition is invalid in routine CELLARRAY","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Then at the frames after the 48th frame it looks identical to the 49th frame. (Image: 2D wave)","category":"page"},{"location":"troubleshooting/#Overhead-brought-by-using-MetaHydroMech.jl","page":"Troubleshooting","title":"Overhead brought by using MetaHydroMech.jl","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Status","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"[x] Resolved       - by calling only one compute!() kernel      - use the const to fix the type instability problem of PTArray","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Description","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Using the same pattern as JustRelax.jl, we added the MetaHydroMech.jl to predefine the environment needed for the use of the ParallelStencil.jl. However this brought us a significant loss in the performance. Before it was around 24 GB/s after the code improvement.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"it = 1, time = 1.653e+00 sec (@ T_eff = 9.00 GB/s) \nit = 2, time = 1.519e-01 sec (@ T_eff = 16.00 GB/s) \nit = 3, time = 3.360e-01 sec (@ T_eff = 12.00 GB/s) \nit = 4, time = 2.038e-01 sec (@ T_eff = 16.00 GB/s) \nit = 5, time = 2.077e-01 sec (@ T_eff = 16.00 GB/s) \nit = 6, time = 2.661e-01 sec (@ T_eff = 15.00 GB/s) \nit = 7, time = 2.399e-01 sec (@ T_eff = 14.00 GB/s) \nit = 8, time = 2.561e-01 sec (@ T_eff = 16.00 GB/s) \nit = 9, time = 2.614e-01 sec (@ T_eff = 16.00 GB/s) \nit = 10, time = 2.914e-01 sec (@ T_eff = 14.00 GB/s) \nit = 11, time = 2.558e-01 sec (@ T_eff = 16.00 GB/s) \nit = 12, time = 2.582e-01 sec (@ T_eff = 16.00 GB/s) \nit = 13, time = 2.649e-01 sec (@ T_eff = 15.00 GB/s) \nit = 14, time = 2.845e-01 sec (@ T_eff = 14.00 GB/s) \nit = 15, time = 2.564e-01 sec (@ T_eff = 16.00 GB/s) \nTest Summary:                              | Pass  Total\nReference test: HydroMech2D_incompressible |    5      5\n     Testing HydroMech tests passed \n","category":"page"},{"location":"part2/#Part-2:-[your-personal-project]","page":"Part 2: [your personal project]","title":"Part 2: [your personal project]","text":"","category":"section"},{"location":"part2/","page":"Part 2: [your personal project]","title":"Part 2: [your personal project]","text":"Solving PDEs of your choice using Julia on (multi-) GPUs -or- applying some performance optimisation to an exisiting or \"bake-off\" problem.","category":"page"},{"location":"part2/#Intro","page":"Part 2: [your personal project]","title":"Intro","text":"","category":"section"},{"location":"part2/","page":"Part 2: [your personal project]","title":"Part 2: [your personal project]","text":"What's all about. Brief overview about:","category":"page"},{"location":"part2/","page":"Part 2: [your personal project]","title":"Part 2: [your personal project]","text":"the process\nthe equations\nthe aims\n...","category":"page"},{"location":"part2/#Methods","page":"Part 2: [your personal project]","title":"Methods","text":"","category":"section"},{"location":"part2/","page":"Part 2: [your personal project]","title":"Part 2: [your personal project]","text":"The methods to be used:","category":"page"},{"location":"part2/","page":"Part 2: [your personal project]","title":"Part 2: [your personal project]","text":"spatial and temporal discretisation\nsolution approach\nhardware\n...","category":"page"},{"location":"part2/#Results","page":"Part 2: [your personal project]","title":"Results","text":"","category":"section"},{"location":"part2/#The-physics-you-are-resolving","page":"Part 2: [your personal project]","title":"The physics you are resolving","text":"","category":"section"},{"location":"part2/#Performance","page":"Part 2: [your personal project]","title":"Performance","text":"","category":"section"},{"location":"part2/#Memory-throughput","page":"Part 2: [your personal project]","title":"Memory throughput","text":"","category":"section"},{"location":"part2/#Weak-scaling","page":"Part 2: [your personal project]","title":"Weak scaling","text":"","category":"section"},{"location":"part2/#Work-precision-diagrams","page":"Part 2: [your personal project]","title":"Work-precision diagrams","text":"","category":"section"},{"location":"part2/#Discussion","page":"Part 2: [your personal project]","title":"Discussion","text":"","category":"section"},{"location":"part2/#References","page":"Part 2: [your personal project]","title":"References","text":"","category":"section"},{"location":"juliageodynamics/#[GeoParams.jl](https://github.com/JuliaGeodynamics/GeoParams.jl.git)-API","page":"JuliaGeodynamics","title":"GeoParams.jl API","text":"","category":"section"},{"location":"juliageodynamics/#Features","page":"JuliaGeodynamics","title":"Features","text":"","category":"section"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"[x] Functors to available creep laws\n[x] Elasticity struct\n[x] Interoperability with ParallelStencil.jl\n[x] compute_viscosity() agnostic to input parameters\n[x] composable custom creep law","category":"page"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"The following API is created using the docstrings avaliable within the ParallelStencil.jl package, and is included for convinience here for look-up purpose. Please refer to the official repository and ask the creator of the packages if anything is unclear.","category":"page"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"<!– ","category":"page"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"CurrentModule = GeoParams","category":"page"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"Modules = [GeoParams]","category":"page"},{"location":"juliageodynamics/#GeoParams.ConstTemp","page":"JuliaGeodynamics","title":"GeoParams.ConstTemp","text":"ConstTemp(T=1000)\n\nSets a constant temperature inside the box\n\nParameters:\n\nT : the value\n\n\n\n\n\n","category":"type"},{"location":"juliageodynamics/#GeoParams.HalfspaceCoolTemp","page":"JuliaGeodynamics","title":"GeoParams.HalfspaceCoolTemp","text":"HalfspaceCoolTemp(Tsurface=0, Tmantle=1350, Age=60, Adiabat=0)\n\nSets a halfspace temperature structure in plate\n\nParameters:\n\nTsurface: surface temperature [C]\nTmantle:  mantle temperature [C]\nAge:      Thermal Age of plate [Myrs]\nAdiabat:  Mantle Adiabat [K/km]\n\n\n\n\n\n","category":"type"},{"location":"juliageodynamics/#GeoParams.LinTemp","page":"JuliaGeodynamics","title":"GeoParams.LinTemp","text":"LinTemp(Ttop=0, Tbot=1000)\n\nSets a linear temperature structure from top to bottom\n\nParameters:\n\nTtop: the value @ the top\nTbot: the value @ the bottom\n\n\n\n\n\n","category":"type"},{"location":"juliageodynamics/#GeoParams.CompTempStruct-Tuple{Any, ConstTemp}","page":"JuliaGeodynamics","title":"GeoParams.CompTempStruct","text":"CompTempStruct(Z, s::AbstractTempStruct)\n\nReturns a temperature vector that matches the coordinate vector and temperature structure that were passed in\n\nParameters:\n\nZ: vector with depth coordinates\ns: Temperature structure (CostTemp, LinTemp, HalfspaceCoolTemp)\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.LithPres-NTuple{6, Any}","page":"JuliaGeodynamics","title":"GeoParams.LithPres","text":"LithPres(MatParam, Phases, ρ, T, dz, g)\n\nIteratively solves a 1D lithostatic pressure profile (compatible with temperature- and pressure-dependent densities)\n\nParameters:\n\nMatParam: a tuple of materials (including the following properties: Phase, Density)\nPhases:   vector with the distribtion of phases\nρ:        density vector for initial guess(can be zeros)\nT:        temperature vector\ndz:       grid spacing\ng:        gravitational accelaration\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.StrengthEnvelopeComp-Union{Tuple{U}, Tuple{N}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N}}, Vector{U}}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N}}, Vector{U}, GeoParams.AbstractTempStruct}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N}}, Vector{U}, GeoParams.AbstractTempStruct, Any}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N}}, Vector{U}, GeoParams.AbstractTempStruct, Any, Int64}} where {N, U}","page":"JuliaGeodynamics","title":"GeoParams.StrengthEnvelopeComp","text":"StrengthEnvelopeComp(MatParam::NTuple{N, AbstractMaterialParamsStruct}, Thickness::Vector{U}, TempType::AbstractTempStruct=LinTemp(0C, 800C), ε=1e-15/s, nz::Int64=101) where {N, U}\n\nCalculates a 1D strength envelope. Pressure used for Drucker Prager plasticity is lithostatic. To visualize the results in a GUI, use StrengthEnvelopePlot.\n\nParameters:\n\nMatParam:  a tuple of materials (including the following properties: Phase, Density, CreepLaws, Plasticity)\nThickness: a vector listing the thicknesses of the respective layers (should carry units)\nTempType:  the type of temperature profile (ConstTemp(), LinTemp(), HalfspaceCoolTemp())\nε:         background strainrate\nnz:        optional argument controlling the number of points along the profile (default = 101)\n\nExample:\n\njulia> using GLMakie\njulia> MatParam = (SetMaterialParams(Name=\"UC\", Phase=1, Density=ConstantDensity(ρ=2700kg/m^3), CreepLaws = SetDislocationCreep(\"Wet Quartzite | Ueda et al. (2008)\"), Plasticity = DruckerPrager(ϕ=30.0, C=10MPa)),\n                   SetMaterialParams(Name=\"MC\", Phase=2, Density=Density=ConstantDensity(ρ=2900kg/m^3), CreepLaws = SetDislocationCreep(\"Plagioclase An75 | Ji and Zhao (1993)\"), Plasticity = DruckerPrager(ϕ=20.0, C=10MPa)),\n                   SetMaterialParams(Name=\"LC\", Phase=3, Density=PT_Density(ρ0=2900kg/m^3, α=3e-5/K, β=1e-10/Pa), CreepLaws = SetDislocationCreep(\"Maryland strong diabase | Mackwell et al. (1998)\"), Plasticity = DruckerPrager(ϕ=30.0, C=10MPa)));\njulia> Thickness = [15,10,15]*km;\n\njulia> StrengthEnvelopeComp(MatParam, Thickness, LinTemp(), ε=1e-15/s)\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.StrengthEnvelopePlot-Tuple{}","page":"JuliaGeodynamics","title":"GeoParams.StrengthEnvelopePlot","text":"StrengthEnvelopePlot(MatParam, Thickness; TempType, nz)\n\nRequires GLMakie\n\nCreates a GUI that plots a 1D strength envelope. In the GUI, temperature profile and strain rate can be adjusted. The Drucker-Prager plasticity uses lithostatic pressure.\n\nParameters:\n\nMatParam:  a tuple of materials (including the following properties: Phase, Density, CreepLaws, Plasticity)\nThickness: a vector listing the thicknesses of the respective layers (should carry units)\nTempType:  the type of temperature profile (LinTemp=default, HalfspaceCoolTemp, ConstTemp)\nnz:        optional argument controlling the number of points along the profile (default = 101)\n\nExample:\n\njulia> using GLMakie\njulia> MatParam = (SetMaterialParams(Name=\"UC\", Phase=1, Density=ConstantDensity(ρ=2700kg/m^3), CreepLaws = SetDislocationCreep(\"Wet Quartzite | Ueda et al. (2008)\"), Plasticity = DruckerPrager(ϕ=30.0, C=10MPa)),\n                   SetMaterialParams(Name=\"MC\", Phase=2, Density=Density=ConstantDensity(ρ=2900kg/m^3), CreepLaws = SetDislocationCreep(\"Plagioclase An75 | Ji and Zhao (1993)\"), Plasticity = DruckerPrager(ϕ=20.0, C=10MPa)),\n                   SetMaterialParams(Name=\"LC\", Phase=3, Density=PT_Density(ρ0=2900kg/m^3, α=3e-5/K, β=1e-10/Pa), CreepLaws = SetDislocationCreep(\"Maryland strong diabase | Mackwell et al. (1998)\"), Plasticity = DruckerPrager(ϕ=30.0, C=10MPa)));\njulia> Thickness = [15,10,15]*km;\n\njulia> StrengthEnvelopePlot(MatParam, Thickness, LinTemp())\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij!-Union{Tuple{N}, Tuple{I}, Tuple{_T}, Tuple{AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{I}, Tuple{Vararg{AbstractMaterialParamsStruct, N}}, _T}} where {_T<:Number, I<:Integer, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij!","text":"compute_p_τij!(Txx, Tyy, Txy, Tii, η_vep, P, Exx, Eyy, Exy, P_o, Txx_o, Tyy_o, Txy_o, phase, MatParam, dt)\n\nComputes 2D deviatoric stress components (Txx,Tyy,Txy) and pressure P given deviatoric strainrate components (Exx,Eyy,Exy) and old deviatoric stresses (Txx_o, Tyy_o, Txy_o) and old pressure P_o (only used for viscoelastic cases). Also returned are Tii (second invariant of the deviatoric stress tensor), and η_vep the viscoelastoplastic effective viscosity.  Also required as input is MatParam, the material parameters for every phase and phase, an integer array of size(Exx) that indicates the phase of every point.\n\nThis function assumes that strainrate points are collocated and that Exx,Eyy,Exy are at the same points.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij-Union{Tuple{I}, Tuple{N2}, Tuple{N1}, Tuple{T}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N1}}, Tuple{Vararg{T, N2}}, T, Any, Tuple{Vararg{T, N2}}, I}} where {T, N1, N2, I<:Integer}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij","text":"P,τij, τII = compute_p_τij(v::NTuple{N1,AbstractMaterialParamsStruct}, εij::NTuple{N2,T}, P_old::T, args, τij_old::NTuple{3,T}, phase::I)\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a collocated grid case with a single phase phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij-Union{Tuple{I}, Tuple{N2}, Tuple{N1}, Tuple{T}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N1}}, Tuple{Vararg{Union{NTuple{4, T}, T}, N2}}, T, Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N2}}, Tuple{Vararg{Union{NTuple{4, I}, I}, N2}}}} where {T, N1, N2, I<:Integer}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij","text":"τij, τII, η_eff = compute_p_τij(v::NTuple{N1,AbstractMaterialParamsStruct}, εij::NTuple, args, τij_old::NTuple, phases::NTuple)\n\nThis computes pressure p and deviatoric stress components τij, their second invariant τII, and effective viscosity η_eff for given deviatoric strainrates εij, old stresses τij_old, phases (integer) for every point and arguments args. It handles staggered grids of various taste\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij-Union{Tuple{N}, Tuple{T}, Tuple{Any, Tuple{Vararg{T, N}}, T, Any, Tuple{Vararg{T, N}}}} where {T, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij","text":"p,τij,τII = compute_p_τij(v, εij::NTuple{n,T}, P_old::T, args,  τij_old::NTuple{N,T})\n\nComputes pressure p and deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a case that all points are collocated and we have a single phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij-Union{Tuple{T}, Tuple{N}, Tuple{Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N}}, T, Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N}}}} where {N, T}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij","text":"p, τij, τII = compute_p_τij(v, εij::NTuple{N,Union{T,NTuple{4,T}}}, P_old::T, args, τij_old::NTuple{3,T})\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a staggered grid case with a single phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij_stagcenter!-Union{Tuple{N}, Tuple{I}, Tuple{_T}, Tuple{AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{I}, AbstractArray{I}, Tuple{Vararg{AbstractMaterialParamsStruct, N}}, _T}} where {_T<:Number, I<:Integer, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij_stagcenter!","text":"compute_τij_stagcenter!(Txx, Tyy, Txy, Tii, η_vep,  P, Exx, Eyy, Exyv, P_o, Txx_o, Tyy_o, Txyv_o, phase_center, phase_vertex, MatParam, dt)\n\nUpdates deviatoric stresses on a staggered grid in a centered based manner (averages strainrates/old stresses from vertices -> centers). Take care of the sizes of the input matrixes:\n\nTxx,Tyy,Txy,Tii,P: 2D matrixes of size (nx,ny) which describe updated deviatoric stress components (x,y,xy, 2nd invariant) at the center point\nη_vep: viscoelastoplastic viscosity @ center (nx,ny)\nExx,Eyy,P_o: deviatoric strain rate components & old pressure @ center\nExy: shear strain rate @ vertices (nx+1,ny+1)\nTxx_o, Tyy_o: deviatoric stress normal components of last timestep at center (nx,ny)\nTxy_o: deviatoric stress shear components at vertices (nx+1,ny+1)\nphase_center: integer array with phase at center points (nx,ny)\nphase_vertex: integer array with phase at vertex points (nx+1,ny+1)\nMatParam: material parameter array that includes a CompositeRheology field which specifies the rheology for different phases\ndt: timestep \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij-Union{Tuple{I}, Tuple{N2}, Tuple{N1}, Tuple{T}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N1}}, Tuple{Vararg{T, N2}}, Any, Tuple{Vararg{T, N2}}, I}} where {T, N1, N2, I<:Integer}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij","text":"τij, τII = compute_τij(v::NTuple{N1,AbstractMaterialParamsStruct}, εij::NTuple{N2,T}, args, τij_old::NTuple{3,T}, phase::I)\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a collocated grid case with a single phase phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij-Union{Tuple{I}, Tuple{N2}, Tuple{N1}, Tuple{T}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N1}}, Tuple{Vararg{Union{NTuple{4, T}, T}, N2}}, Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N2}}, Tuple{Vararg{Union{NTuple{4, I}, I}, N2}}}} where {T, N1, N2, I<:Integer}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij","text":"τij, τII, η_eff = compute_τij(v::NTuple{N1,AbstractMaterialParamsStruct}, εij::NTuple, args, τij_old::NTuple, phases::NTuple)\n\nThis computes deviatoric stress components τij, their second invariant τII, and effective viscosity η_eff for given deviatoric strainrates εij, old stresses τij_old, phases (integer) for every point and arguments args. This handles various staggered grid arrangements; if staggered components are given as NTuple{4,T}, they will be averaged. Note that the phase of all staggered points should be the same.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij-Union{Tuple{N}, Tuple{T}, Tuple{Any, Tuple{Vararg{T, N}}, Any, Tuple{Vararg{T, N}}}} where {T, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij","text":"τij,τII = compute_τij(v, εij::NTuple{n,T}, args, τij_old::NTuple{N,T})\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a case that all points are collocated and we have a single phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij-Union{Tuple{T}, Tuple{N}, Tuple{Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N}}, Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N}}}} where {N, T}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij","text":"τij, τII = compute_τij(v, εij::NTuple{N,Union{T,NTuple{4,T}}}, args, τij_old::NTuple{3,T})\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a staggered grid case with a single phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij_stagcenter!-Union{Tuple{N}, Tuple{I}, Tuple{_T}, Tuple{AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{I}, AbstractArray{I}, Tuple{Vararg{AbstractMaterialParamsStruct, N}}, _T}} where {_T<:Number, I<:Integer, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij_stagcenter!","text":"compute_τij_stagcenter!(Txx, Tyy, Txy, Tii, η_vep,  Exx, Eyy, Exyv, P, Txx_o, Tyy_o, Txyv_o, phase_center, phase_vertex, MatParam, dt)\n\nUpdates deviatoric stresses on a staggered grid in a centered based manner (averages strainrates/old stresses from vertices -> centers). Take care of the sizes of the input matrixes:\n\nTxx,Tyy,Txy,Tii: 2D matrixes of size (nx,ny) which describe updated deviatoric stress components (x,y,xy, 2nd invariant) at the center point\nη_vep: viscoelastoplastic viscosity @ center (nx,ny)\nExx,Eyy,P: deviatoric strain rate components & pressure @ center \nExy: shear strain rate @ vertices (nx+1,ny+1)\nTxx_o, Tyy_o: deviatoric stress normal components of last timestep at center (nx,ny)\nTxy_o: deviatoric stress shear components at vertices (nx+1,ny+1)\nphase_center: integer array with phase at center points (nx,ny)\nphase_vertex: integer array with phase at vertex points (nx+1,ny+1)\nMatParam: material parameter array that includes a CompositeRheology field which specifies the rheology for different phases\ndt: timestep \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.second_invariant_staggered-Union{Tuple{T}, Tuple{NTuple{4, T}, NTuple{4, T}, NTuple{4, T}, Tuple{T, T, T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.second_invariant_staggered","text":"second_invariant_staggered(Axx::NTuple{4,T}, Ayy::NTuple{4,T}, Azz::NTuple{4,T}, Aij::NTuple{3,T}) where {T}\n\nComputes the second invariant of the 2D tensor A when its diagonal components  need to be maped from cell center to cell vertex. Axx, Ayy, and Azz are tuples containinig the diagonal terms of A at the cell centers around the i-th vertex., and Aij is a tuple that contains the off-diagonal components at the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.second_invariant_staggered-Union{Tuple{T}, Tuple{NTuple{4, T}, NTuple{4, T}, Number}} where T","page":"JuliaGeodynamics","title":"GeoParams.second_invariant_staggered","text":"second_invariant_staggered(Axx::NTuple{4,T}, Ayy::NTuple{4,T}, Axy::Number) where {T}\n\nComputes the second invariant of the 2D tensor A when its diagonal components  need to be maped from cell center to cell vertex. Axx, and Ayy are tuples containinig the diagonal terms of A at the cell centers around the i-th vertex., and Axy is the xy component at the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.second_invariant_staggered-Union{Tuple{T}, Tuple{Tuple{T, T, T}, NTuple{4, T}, NTuple{4, T}, NTuple{4, T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.second_invariant_staggered","text":"second_invariant_staggered(Aii::NTuple{3,T}, Ayz::NTuple{4,T}, Axz::NTuple{4,T}, Axy::NTuple{4,T}) where {T}\n\nComputes the second invariant of the 2D tensor A when its off-diagonal components  need to be maped from cell center to cell vertex. Aii is a tuple containinig the diagonal terms of A at the i-th vertex, and Ayz, Axz, and Axy are tuples that contain the off-diagonal components of the tensor at the cell centers around the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.second_invariant_staggered-Union{Tuple{T}, Tuple{Tuple{T, T}, NTuple{4, T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.second_invariant_staggered","text":"second_invariant_staggered(Aii::NTuple{2,T}, Axy::NTuple{4,T}) where {T}\n\nComputes the second invariant of the 2D tensor A when its off-diagonal components  need to be maped from cell center to cell vertex.  Aii is a tuple containinig the diagonal terms of A at the i-th vertex, and Axy is a tuple that contains A_xy at the cell centers around the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_p_τII_0D!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Union{Tuple, CompositeRheology, Parallel}, Vector{T}, Vector{T}, Any, AbstractVector{T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.time_p_τII_0D!","text":"time_p_τII_0D!(P_vec::Vector{T}, τ_vec::Vector{T}, v::CompositeRheology, εII_vec::Vector{T}, εvol_vec::Vector{T}, args, t_vec::AbstractVector{T}) where {T}\n\nComputes stress-time evolution for a 0D (homogeneous) setup with given shear and volumetric strainrate vectors (which can vary with time).\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_p_τII_0D-Tuple{Union{Tuple, CompositeRheology, Parallel}, Number, Number, Any}","page":"JuliaGeodynamics","title":"GeoParams.time_p_τII_0D","text":"t_vec, P_vec, τ_vec = time_p_τII_0D(v::CompositeRheology, εII::Number, εvol::Number, args; t=(0.,100.), τ0=0., nt::Int64=100)\n\nThis performs a 0D constant strainrate experiment for a composite rheology structure v, and a given, constant, shear strainrate εII and volumetric strainrate εvol, as well as rheology arguments args. The initial stress τ0, the time range t and the number of timesteps nt can be modified \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_τII_0D!-Union{Tuple{T}, Tuple{N}, Tuple{Array{Tuple{Vararg{T, N}}, 1}, Vector{T}, Union{Tuple, CompositeRheology, Parallel}, Array{Tuple{Vararg{T, N}}, 1}, Any, AbstractVector{T}}} where {N, T}","page":"JuliaGeodynamics","title":"GeoParams.time_τII_0D!","text":"time_τII_0D!(τ_vec::Vector{NTuple{N,T}}, τII_vec::Vector{T}, v::Union{CompositeRheology,Tuple, Parallel}, ε_vec::Vector{NTuple{N,T}}, args, t_vec::AbstractVector{T}; verbose=false) where {N,T}\n\nComputes stress-time evolution for a 0D (homogeneous) setup with given strainrate tensor (which can vary with time).\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_τII_0D!-Union{Tuple{T}, Tuple{Vector{T}, Union{Tuple, CompositeRheology, Parallel}, Vector{T}, Any, AbstractVector{T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.time_τII_0D!","text":"time_τII_0D!(τ_vec::Vector{T}, v::CompositeRheology, εII_vec::Vector{T}, args, t_vec::AbstractVector{T}) where {T}\n\nComputes stress-time evolution for a 0D (homogeneous) setup with given strainrate vector (which can vary with time).\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_τII_0D-Tuple{Union{Tuple, CompositeRheology, Parallel}, Number, Any}","page":"JuliaGeodynamics","title":"GeoParams.time_τII_0D","text":"t_vec, τ_vec = time_τII_0D(v::CompositeRheology, εII::Number, args; t=(0.,100.), τ0=0., nt::Int64=100)\n\nThis performs a 0D constant strainrate experiment for a composite rheology structure v, and a given, constant, strainrate εII and rheology arguments args. The initial stress τ0, the time range t and the number of timesteps nt can be modified \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_τII_0D-Union{Tuple{T}, Tuple{N}, Tuple{Union{Tuple, CompositeRheology, Parallel}, Tuple{Vararg{T, N}}, Any}} where {N, T}","page":"JuliaGeodynamics","title":"GeoParams.time_τII_0D","text":"t_vec, τ_vec = time_τII_0D(v::CompositeRheology, ε::NTuple{N,T}, args; t=(0.,100.), τ0=NTuple{N,T}, nt::Int64=100)\n\nThis performs a 0D constant strainrate experiment for a composite rheology structure v, and a given, constant, strainrate tensor ε and rheology arguments args. The initial deviatoric stress tensor τ, the time range t and the number of timesteps nt can be modified \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"–>","category":"page"},{"location":"computational-earthquake-physics/#Computational-Earthquake-Physics","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"","category":"section"},{"location":"computational-earthquake-physics/#Geodynamics","page":"Computational Earthquake Physics","title":"Geodynamics","text":"","category":"section"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"\"The crucial point that was finally understood by the geological community is that both viscous (i.e., fluid-like) and elastic (i.e., solid-like) behaviour is a characteristic of the Earth depending on the time scale of deformation. The Earth’s mantle, which is elastic on a human time scale, is viscous on geological time scales (>10 000 years) and can be strongly internally deformed due to solid-state creep. – (Gerya 2019)\"","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"The dual viscous-elastic behaviour of the Earth can be demonstrated using the \"silly putty\", which jumps up like a rubber ball (acts like solid) when we drop it on the floor for a very short timescale, but demonstrates more fluid-like behaviors in a longer time period (few days/weeks).","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"See demonstration of the visco-elasticity here","category":"page"},{"location":"computational-earthquake-physics/#Rock-rheology","page":"Computational Earthquake Physics","title":"Rock rheology","text":"","category":"section"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Rheology:  the composite physical property characterizing deformation behavior of a material.","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Rock rheology:  includes several different deformation mechanisms, and is in general visco-elasto-plastic.  Elastic properties are important to be taken into account on a relatively short time scale (10^4 years) for  fast processes like magma intrusion. On the other hand, at low temperature rocks can be subjected to localized  brittle and plastic deformation.","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Followingly is a small summary of different types of rheology. The major difference between them is the composition of the bulk deviatoric strain rate dotepsilon_ij. For example, it is decomposed into 2 respective components for visco-plastic rheology as dotepsilon_ij = dotepsilon_ijtext(viscous) + dotepsilon_ijtext(plastic)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"visco-plastic: a strain rate based formation is more suitable. Simplification by assuming that elastic effects are negligible and can be ignored on the long time scales.","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"visco-elastic: a stress-based formulation is more suitable. Viscous and elastic rheological relations are combined under certain physical assumptions. Maxwell visco-elastic rheology is the most commenly used type. Definitions of shear and bulk moduli are modified in the equations. More see section 12.4 in (Gerya 2019)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"visco-elasto-plastic: a stress-based formulation is more suitable. It characterises the non-linear instantaneous response at higher stress levels or temperature","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"poro-elastic: Biot's model and its validity at low stress level and negligible viscous relaxation","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"poro-elasto-plastic: ","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"thermo-hydro-chemico-mechanical (THCM): thermal and chemical couplings to deformation (mechanics)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"NOTE: in general, coupling among processes triggers non-linear interactions that may result in significant and spontaneous localization of flow, heat and deformation.","category":"page"},{"location":"3D-hydro-mechanical-solver/#D-Hydro-mechanical-Solver","page":"3D-Hydro-mechanical solver","title":"3D Hydro-mechanical Solver","text":"","category":"section"},{"location":"pseudo-transient-method/#Pseudo-Transient-Method","page":"Pseudo Transient Method","title":"Pseudo-Transient Method","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The Pseudo-Transient Method (PT method), is an iterative method which is:","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"matrix-free\nbuilds on a fixed-point iteration\nupdate of each grid point is local, does not require global reductions\nenables easy-to-develop multi-physics coupling due to its conciseness\nsimilarity between mathematical and discretised code notation","category":"page"},{"location":"pseudo-transient-method/#History","page":"Pseudo Transient Method","title":"History","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1911 - Pioneering work by Richardson </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Richardson proposed an iterative solution approach to PDEs related to dam-engineering calculations. Early developed iterative algorithms are well-suited for early low-memory computers but lack in efficient convergence rates.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1950 - First present of the PT method in the literature (Frankel)</summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The idea of accelerating the convergence by increasing the order of PDE dates back to the work by Frankel (1950). Frankel noted the analogy between the iteration process and transient physics. And the accelarated method was called the second-order Richardson method.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Introduced as an extension of the Richardson and Liebmann methods, with dependency on the previous iterations added.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1965 - The PT method originated as a dynamic-relaxation method (Oter) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The PT method was applied for calculating the stresses and displacements in concrete pressure vessels.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1972 - Enhanced convergence rates of the PT methods showed (Young) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The PT method was firstly performed on par.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1976 - First introduction in geosciences (Cundall) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The PT method was introduced by Cundall as the Fast Lagranngian Analysis of Continua (FLAC) algorithm","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1993, 1994 - Applications of the FLAC method (Poliakov et al.) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The FLAC method was successfully applied to simulate the Rayleigh–Taylor instability in visco-elastic flow (Poliakov et al. 1993), and the formation of shear bands in rocks (Poliakov et al. 1994).","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1993 - Application in buckling (Ramesh and Krishnamoorthy) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1999 - Application in form-finding (Barnes) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>2009 - Application in failure (Kilic and Madenci) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>2011 - FEM community still referenced it as the DR-method (Rezauee-Pajand) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>2020 - Review on the accurate estimate of extremal eigenvalues for the Chebyshev's semi-iterative methods (Saad) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"NOTE: second-order or extrapolated methods are also termed semi-iterative.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>2022 - Accelerated pseudo-transient method (Räss et al.) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Assessing the robustness and scalability of the accelerated pseudo-transient method Räss et al. (2022)","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/#Accelerated-Pseudo-Transient-Method","page":"Pseudo Transient Method","title":"Accelerated Pseudo-Transient Method","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"(Image: DOI) (Image: DOI)","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Followingly we abstract some important aspects reported in the paper \"Assessing the robustness and scalability of the accelerated pseudo-transient method Räss et al. (2022), in which the accelerated PT method was introduced.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"It has the following advantages:","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Ensures the iteration count to scale linearly with numerical resolution increase","category":"page"},{"location":"pseudo-transient-method/#Application","page":"Pseudo Transient Method","title":"Application","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The method is applicable to:","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Strongly nonlinear problems\nshear-banding in a visco-elasto-plastic medium","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Finding solution of stationary problems\nFinding solution of problems with transient terms\ninvolve both physical time t and pseudo-time tau\nalso called \"dual-time method\" or \"dual time stepping\" (Mandal et al 2011) ","category":"page"},{"location":"pseudo-transient-method/#Derivation","page":"Pseudo Transient Method","title":"Derivation","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"A physically motivated derivation is well-presented . To understand how powerful the PT method is, we cited here a small paragraph from the paper:","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"\"The PT methods build on a physical description of a process. It therefore becomes possible to model strongly nonlinear processes and achieve convergence starting from nearly arbitrary initial conditions.\"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The accelerated PT method for elliptic equations is mathematically equivalent to the second-order Richardson rule.","category":"page"},{"location":"pseudo-transient-method/#Numerics","page":"Pseudo Transient Method","title":"Numerics","text":"","category":"section"},{"location":"pseudo-transient-method/#Convergence","page":"Pseudo Transient Method","title":"Convergence","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The convergence rate of the accelerated PT method is very sensitive to the iteration parameters' choice.","category":"page"},{"location":"pseudo-transient-method/#Iteration-parameters","page":"Pseudo Transient Method","title":"Iteration parameters","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The choice of the iteration parameters are essential for the accelerated PT method as the method is highly sensitive to it.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"By analysing the equations of the basic physical processes in their continuous form, we can select the optimal iteration parameters. For more information regarding how to choose the optimal iterations parameters see here.","category":"page"},{"location":"pseudo-transient-method/#Boundary-conditions-(B.C.)","page":"Pseudo Transient Method","title":"Boundary conditions (B.C.)","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"\"The choice of the type of boundary conditions affects only the values of the optimal iteration parameters and does not limit the generality of the method\"","category":"page"},{"location":"pseudo-transient-method/#Robustness","page":"Pseudo Transient Method","title":"Robustness","text":"","category":"section"},{"location":"pseudo-transient-method/#Performance","page":"Pseudo Transient Method","title":"Performance","text":"","category":"section"},{"location":"pseudo-transient-method/#Choice-of-physical-processes","page":"Pseudo Transient Method","title":"Choice of physical processes","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The choice of transient physical processes influences the performance of iterative methods.","category":"page"},{"location":"pseudo-transient-method/#CPU-based","page":"Pseudo Transient Method","title":"CPU-based","text":"","category":"section"},{"location":"pseudo-transient-method/#GPU-based","page":"Pseudo Transient Method","title":"GPU-based","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Weak scaling benchmarks with more than 96% parallel efficiency on 2197 Nvidia Tesla P100 GPUs on the Piz Daint supercomputer [Räss et al. (2022)]","category":"page"},{"location":"justrelax-overview/#[JustRelax.jl](https://github.com/PTsolvers/JustRelax.jl)","page":"Overview","title":"JustRelax.jl","text":"","category":"section"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"The JustRelax.jl package exploits the two powerful emerging paradigms in HPC, Massively parallel relaxation-cased solvers and HPC with Julia.","category":"page"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"The package is aimed to provide a reusable, extensible and high-performance framework, so that they may be applied within existing application codes and used to develop new ones. ","category":"page"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"JustRelax contains solvers which are based on the accelerated pseudo-transient (PT) iterative method. ","category":"page"},{"location":"justrelax-overview/#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"[x] 2D viscous stokes\n[x] 2D visco-elsatic stokes\n[ ] 2D non-Newtonian rheology\n[ ] 2D visco-elasto-plasticity\n[ ] 2D 2-phase flow\n[x] 3D Visco-elastic stokes\n[ ] Add the Zaremba-Jaumann rate of the Cauchy stress\n[ ] Refactor thermal diffusion (2D and 3D)\n[x] Paraview interface for 3D viz with WriteVTK.jl\n[ ] Advection: Particles-in-cell\n[ ] Scalability tests\n[ ] Support for GeoParams.jl (ongoing)\n[ ] I/O","category":"page"},{"location":"justrelax-overview/#Workflow","page":"Overview","title":"Workflow","text":"","category":"section"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"The JustRelax.jl package contains the solvers for different geophysical problems modelled using PDEs.","category":"page"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"The package is self-contained and is equipped with the boundary conditions and global computational kernels","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2022 You WuPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"part1/#Part-1:-3D-multi-XPUs-diffusion-solver","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Steady state solution of a diffusive process for given physical time steps using the pseudo-transient acceleration (using the so-called \"dual-time\" method).","category":"page"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"💡 Use ParallelStencil.jl and ImplicitGlobalGrid.jl for the (multi-)XPU implementation. You are free to use either @parallel or @parallel_indices type of kernel definition.","category":"page"},{"location":"part1/#Intro","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Intro","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"What's all about. Brief overview about:","category":"page"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"the process\nthe equations\nthe aims\n...","category":"page"},{"location":"part1/#Methods","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Methods","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"The methods to be used:","category":"page"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"spatial and temporal discretisation\nsolution approach\nhardware\n...","category":"page"},{"location":"part1/#Results","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Results","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Results section","category":"page"},{"location":"part1/#D-diffusion","page":"Part 1: 3D multi-XPUs diffusion solver","title":"3D diffusion","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Report an animation of the 3D solution here and provide and concise description of the results. Unleash your creativity to enhance the visual output.","category":"page"},{"location":"part1/#Performance","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Performance","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Briefly elaborate on performance measurement and assess whether you are compute or memory bound for the given physics on the targeted hardware.","category":"page"},{"location":"part1/#Memory-throughput","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Memory throughput","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Strong-scaling on CPU and GPU -> optimal \"local\" problem sizes.","category":"page"},{"location":"part1/#Weak-scaling","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Weak scaling","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Multi-GPU weak scaling","category":"page"},{"location":"part1/#Work-precision-diagrams","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Work-precision diagrams","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Provide a figure depicting convergence upon grid refinement; report the evolution of a value from the quantity you are diffusing for a specific location in the domain as function of numerical grid resolution. Potentially compare against analytical solution.","category":"page"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Provide a figure reporting on the solution behaviour as function of the solver's tolerance. Report the relative error versus a well-converged problem for various tolerance-levels. ","category":"page"},{"location":"part1/#Discussion","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Discussion","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Discuss and conclude on your results","category":"page"},{"location":"part1/#References","page":"Part 1: 3D multi-XPUs diffusion solver","title":"References","text":"","category":"section"},{"location":"part1/","page":"Part 1: 3D multi-XPUs diffusion solver","title":"Part 1: 3D multi-XPUs diffusion solver","text":"Provide here refs if needed.","category":"page"},{"location":"viscous_rheology/#Lecture-9-Gerya","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"","category":"section"},{"location":"viscous_rheology/#Viscous-Rheology","page":"Lecture 9 - Gerya","title":"Viscous Rheology","text":"","category":"section"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"Crystallized materials can deform during solid-state creep","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"=> sensitive to pressure, temperature.","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"eg. mantle viscosity measured from glacial terrasses 10^2 Pa cdot s","category":"page"},{"location":"viscous_rheology/#Classification-of-the-responses","page":"Lecture 9 - Gerya","title":"Classification of the responses","text":"","category":"section"},{"location":"viscous_rheology/#).-Newtonian-rhelogy","page":"Lecture 9 - Gerya","title":"1). Newtonian rhelogy","text":"","category":"section"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"$","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"\\dot{\\gamma}' = A \\cdot \\tau$","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"Viscous strain rate is proportional to applied deviatoric stress","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"Newtonian because of the linear relationship","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"=> this behavior characteristic for diffusion creep ","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"diffusion inside atoms, produce deformation of the crystal (Myr)\ncaused by jumping between vacancies\nessential for the fact that the viscousity of the rock depends on the temperature","category":"page"},{"location":"viscous_rheology/#Example:-Herring-Nabarro-creep","page":"Lecture 9 - Gerya","title":"Example: Herring-Nabarro creep","text":"","category":"section"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"diffusion through crystal interior","category":"page"},{"location":"viscous_rheology/#Example:-Cable'-creep","page":"Lecture 9 - Gerya","title":"Example: Cable' creep","text":"","category":"section"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"diffusion through the crystal boundaries","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"=> faster diffusion","category":"page"},{"location":"viscous_rheology/#Dependency-of-creep's-speed-and-the-grain-size","page":"Lecture 9 - Gerya","title":"Dependency of creep's speed and the grain size","text":"","category":"section"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"For the grain size the relation holds (power law dependence)","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"A tilde frac1h^2","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"=> eg. slap is related to the grain size]]","category":"page"},{"location":"viscous_rheology/#).-Non-Newtonian-Rheology","page":"Lecture 9 - Gerya","title":"2). Non-Newtonian Rheology","text":"","category":"section"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"dotgamma = B cdpt tau^n","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":", where normally n  1, typically n = 3.","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"=> doubling the stresses obtain 8 times faster the strain rate","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"=> this relation is caused by dislocation creep","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"defects of crystal lattice","category":"page"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"=> NOTE: coefficient B is not dependent on the grain size","category":"page"},{"location":"viscous_rheology/#Dislocation-density","page":"Lecture 9 - Gerya","title":"Dislocation density","text":"","category":"section"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"depends on deviatoric stress","category":"page"},{"location":"viscous_rheology/#Experimentally-calibrated-flow-law","page":"Lecture 9 - Gerya","title":"Experimentally-calibrated flow law","text":"","category":"section"},{"location":"viscous_rheology/","page":"Lecture 9 - Gerya","title":"Lecture 9 - Gerya","text":"desired: steady state deformation","category":"page"},{"location":"viscous_rheology/#TODO:-watch-the-2nd-part-of-the-video-of-week09","page":"Lecture 9 - Gerya","title":"TODO: watch the 2nd part of the video of week09","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/#D-Hydro-mechanical-Solver","page":"2D-Hydro-mechanical solver","title":"2D Hydro-mechanical Solver","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"The solvers in our package aims to solve the two-phase flow equations.","category":"page"},{"location":"2D-hydro-mechanical-solver/#Intro:-Stokes-flow","page":"2D-Hydro-mechanical solver","title":"Intro: Stokes flow","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/#a).-Stokes-equation","page":"2D-Hydro-mechanical solver","title":"a). Stokes equation","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"the following Stokes equation describes the creeping flow of a viscous fluid","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"General form:","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"vecnabla cdot underlineunderlinesigma - vecnabla P = vecf_textext","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"Simplified form:","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"Under the assumption that viscosity is isotropic and the fluid is incompressible","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"eta vecnabla^2 vecv - vecnabla P = vecf_textext","category":"page"},{"location":"2D-hydro-mechanical-solver/#b).-Continuity-equation","page":"2D-Hydro-mechanical solver","title":"b). Continuity equation","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"fracpartial rhopartial t + vecnabla cdot (rho vecv) = 0","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"","category":"page"},{"location":"2D-hydro-mechanical-solver/#Hydro-mechanical-2-phase-flow","page":"2D-Hydro-mechanical solver","title":"Hydro-mechanical 2-phase flow","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"Comparing to the Stokes flow, equations for three more unknowns are to be solved which are related to the Darcy flux. Here we assume the constant porosity of the solid.","category":"page"},{"location":"2D-hydro-mechanical-solver/#Case-1:-Incompressible","page":"2D-Hydro-mechanical solver","title":"Case 1: Incompressible","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"no mass transfer between the solid and fluid and vice versa\nused in the current developed code of JustRelax.jl","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"i). Total momentum (solid matrix and fluid)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot underlineunderlinesigma + g rho^t = nabla p^t","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"ii). Fluid momentum","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"v^D = -frack^phieta^f(nabla p^f-rho^fg)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"iii). incompressible solid mass","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot v^s = - fracp^t-p^feta^phi(1-phi)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"iv). incompressible fluid mass","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot v^D = fracp^t-p^feta^phi(1-phi)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"NOTE 1: Porosity-dependent permeability is given by k^phi = k^phi_r (fracphiphi_r)^m (frac1- phi1-phi_r)^n","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"NOTE 2: Porosity-dependent viscosity is given by eta^phi = K_p fraceta^tphi","category":"page"},{"location":"2D-hydro-mechanical-solver/#Case-2:-Compressible","page":"2D-Hydro-mechanical solver","title":"Case 2: Compressible","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"used in the H-MEC model","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"i). Total momentum (solid matrix and fluid)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot underlineunderlinesigma + g rho^t = rho^tfracD^sv^sDt","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"ii). Fluid momentum","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"v^D = -frack^phieta^f(nabla p^f-rho^f(g-fracD^fv^fD t))","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"iii). Fully compressible solid mass","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot v^s = -frac1K^d(fracD^s p^tD t - alpha fracD^f p^fDt) - fracp^t-p^feta^phi(1-phi)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"iv). Fully compressible fluid mass","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot v^D = fracalphaK^d(fracD^s p^tD t - frac1B fracD^f p^fDt) + fracp^t-p^feta^phi(1-phi)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"NOTE:  porosity-dependent permeability","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"k^phi = k^* (fracphi^*phi)^n","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"with reference values abstracted from the Table 1\nreference permeability     ↔    k^* = 10^-16 m^2\nreference porosity         ↔    phi^* = 1 ","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"NOTE:  effective visco-plastic compaction viscosity","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"eta^phi = frac2m1+m fraceta_s(vp)phi =^m=1 fraceta_s(vp)phi","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"geometrical factor m = 1 for cylindrical pores\neffective visco-plastic shear viscosity of the solid matrix ↔ eta_s(vp)","category":"page"},{"location":"2D-hydro-mechanical-solver/#Others","page":"2D-Hydro-mechanical solver","title":"Others","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"McKenzie (1984)","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"HydroMech.jl in still in its development and is expected to release its first version by the end of Dec. 2022.","category":"page"},{"location":"overview/#Structure","page":"Overview","title":"Structure","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"HydroMech.jl\n├── benchmark        # run scripts for reproducing benchmarks in the paper\n├── CNAME\n├── docs             # documentation and final report\n├── LICENSE\n├── Manifest.toml\n├── Project.toml\n├── README.md\n├── scripts          # contains the most current version of the scripts in development\n├── src              # should contain the developed code after verification of the correctness\n└── test             # test/part*.jl ↔ testing scripts","category":"page"},{"location":"overview/#Testing","page":"Overview","title":"Testing","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"unit and reference testing are included within the test folder","category":"page"},{"location":"#HydroMech.jl","page":"Home","title":"HydroMech.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Hydro-mechanical solver package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HydroMech.jl was developed during the attendance of the course 101-0250-00L at ETH Zürich, which is designed to be a  module of the PTSolver/JustRelax.jl package. It utilizes the pseudo-transient method for efficiency of the PDEs  solving. It is designed to be able to run on both CPUs and GPUs.","category":"page"},{"location":"hydromech/#HydroMech.jl-API","page":"HydroMech.jl","title":"HydroMech.jl API","text":"","category":"section"},{"location":"hydromech/","page":"HydroMech.jl","title":"HydroMech.jl","text":"CurrentModule = HydroMech","category":"page"},{"location":"hydromech/","page":"HydroMech.jl","title":"HydroMech.jl","text":"Modules = [HydroMech]","category":"page"},{"location":"hydromech/#HydroMech.HydroMech","page":"HydroMech.jl","title":"HydroMech.HydroMech","text":"Main module for HydroMech.jl\n\nA collection of hydro-mechanical solvers for incompressible and compressible 2-phase flow.\n\n\n\n\n\n","category":"module"},{"location":"hydromech/#HydroMech.HydroMech2D_compressible-Tuple{}","page":"HydroMech.jl","title":"HydroMech.HydroMech2D_compressible","text":"CompressibleHydroMechEquations2D\n\nThe compressible two-phase flow equations without the inertial term. \n\ni). Total momentum (solid matrix and fluid)\n\nnabla cdot underlineunderlinesigma + g rho^t = 0\n\nii). Fluid momentum\n\nv^D = -frack^phieta^f(nabla p^f-rho^fg)\n\niii). Compressible solid mass\n\nnabla cdot v^s = -frac1K^d(fracD^s p^tD t - alpha fracD^f p^fDt) - fracp^t-p^feta^phi(1-phi)\n\niv). Compressible fluid mass\n\nnabla cdot v^D = fracalphaK^d(fracD^s p^tD t - frac1B fracD^f p^fDt) + fracp^t-p^feta^phi(1-phi)\n\n\n\n\n\n","category":"method"},{"location":"hydromech/#HydroMech.HydroMech2D_incompressible-Tuple{}","page":"HydroMech.jl","title":"HydroMech.HydroMech2D_incompressible","text":"IncompressibleHydroMechEquations2D\n\nThe incompressible two-phase flow equations without the inertial term. \n\ni). Total momentum (solid matrix and fluid)\n\nnabla cdot underlineunderlinesigma + g rho^t = 0\n\nii). Fluid momentum\n\nv^D = -frack^phimu^f(nabla p^f-rho^fg)\n\niii). Incompressible solid mass\n\nnabla cdot v^s = - fracp^t-p^feta^phi(1-phi)\n\niv). Incompressible fluid mass\n\nnabla cdot v^D = fracp^t-p^feta^phi(1-phi)\n\n\n\n\n\n","category":"method"}]
}
